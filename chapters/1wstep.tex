% T³o:
Prawdopodobnie nie istniej¹ programy wolne od b³êdów. Z ca³¹ pewnoœci¹ istniej¹ programy, które zawieraj¹ zbyt du¿¹ liczbê b³êdów. Ka¿dy kto tworzy oprogramowanie chcia³by aby by³o ono wolne od wad. Podstawowym narzêdziem pozwalaj¹cym na sprawdzenie czy program dzia³a poprawnie s¹ testy. Powstaj¹ coraz bardziej wyszukane metody i metodyki testowania oprogramowania, a wszystko po to oprogramowanie dzia³a³o zgodnie z oczekiwaniami, czyli aby cechowa³o siê wysok¹ jakoœci¹. Testowanie i inspekcje kodu pozwalaj¹ zapewniæ odpowiedni¹ jakoœæ oprogramowania, ale s¹ kosztowne. Bazuj¹c na zasadzie Pareto \cite{endres2003handbook} wiemy, ¿e oko³o 80\% defektów pochodzi z 20\% modu³ów \cite{concas2011distribution}. Wiedz¹c, które modu³y nale¿y poddaæ inspekcji, mo¿na znacznie obni¿yæ iloœæ pracy potrzebn¹ do znalezienia wiêkszoœci b³êdów, a co za tym idzie znacz¹co zmniejszyæ koszt takich inspekcji.

Kod Ÿród³owy oprogramowania zazwyczaj sk³ada siê z wielu plików, które s¹ organizowane w pakiety (ang. \textit{packages}). W jêzyku Java pliki zawieraj¹ klasy (ang. \textit{class}), a ka¿da klasa mo¿e zawieraæ metody (ang. \textit{method}). Powsta³o wiele metod predykcji defektów, na ró¿nych poziowach granulacji: od pakietów, przez pliki, klasy, metody, na pojedynczych zmianach (ang. \textit{hunk} \cite{ferzund2009empirical, ferzund2009software}) skoñczywszy \cite{hall2012systematic, catal2009systematic, d2010extensive, d2012evaluating}. Jak wykazano m.in. w \cite{giger2012method} i \cite{hata2012bug}, predykcja b³êdów na poziomie metod dostarcza dok³adniejszych danych na temat lokalizacji b³êdów, dziêki czemu ich odnajdywanie jest efektywniejsze.

Predykcja defektów oprogramowania wykorzystuje techniki eksploracji danych, g³ównie s¹ to metody statystyczne i metody uczenia maszynowego. Kluczowym elementem w tych procesach s¹ w³aœnie dane. To na ich podstawie algorytmy uczenia maszynowego s¹ w stanie formu³owaæ regu³y decyzyjne. W in¿ynierii oprogramowania tymi danymi s¹ róznego rodzaju metryki oprogramowania. Podzia³ metryk oraz ich zastosowanie zosta³y szerzej opisane w rozdziale \ref{rola-metryk}.

Gromadzenie danych (metryk) z projektów jest czasoch³onne, wymaga du¿o pracy --- pobierania lub kopiowania projektów, mocy obliczeniowej do wyliczenia metryk. Potrzebne jest stworzenie uniwersalnych rozwi¹zañ s³u¿¹cych do tego celu oraz nastawienie na mo¿liwoœæ rozszerzania zestawu narzêdzi, które mog¹ byæ ze sob¹ dowolnie zestawiane. Te wymagania spe³nia platforma DePress \cite{madeyski2014software}, która jest rozwijana przy udziale studentów i pracowników Politechniki Wroc³awskiej oraz pracowników Capgemini Polska. Wiêcej informacji o DePress zawarto w rozdziale \ref{depress}.

Wstêpne przeszukiwanie literatury wykaza³o niewielk¹ iloœæ Ÿróde³ œciœle odpowiadaj¹cych zagadnieniu predykcji defektów na niskim poziomie granulacji. Jest to g³ówny kierunek tych badañ a ich celem jest przede wszystkim opracowanie nowego modelu, który mia³by s³u¿yæ do efektywnego wskazywania miejsc w oprogramowaniu, w których znajduj¹ siê b³êdy. Pozwololi³oby to na ograniczenie iloœci pracy potrzebnej do przejrzenia krytycznych miejsc i naprawienia b³êdów.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cele pracy}

\noindent Cele pracy dyplomowej:
\begin{itemize}
	\item Przegl¹d literatury pod k¹tem predykcji defektów oprogramowania, szczególnie na niskim poziomie granulacji.
	\item Budowa nowych lub rozbudowa istniej¹cych narzêdzi s³u¿¹cych do wyliczenia metryk oprogramowania, wspó³pracuj¹cych z wersjonowanymi repozytoriami kodu (SVN oraz Git).
	\item Zebranie danych z projektów o otwartych Ÿród³ach na potrzeby predykcji defektów.
	\item Budowa modeli predykcji z wykorzystaniem zebranych danych.
	\item Ocena stworzonych narzêdzi oraz zebranych danych.
	\item Ewaluacja modeli predykcji i ocena ich skutecznoœci.
\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zwi¹zek z innymi pracami}

\noindent Na pocz¹tku prac dokonano przegl¹du literatury aby okreœliæ aktualny stan wiedzy (ang. \textit{state of the art}) w badanej dziedzinie. Przegl¹d literatury pozwoli³ udzieliæ odpowiedzi na nastêpuj¹ce pytania:
\begin{itemize}
	\item {\bf Jakie istniej¹ metody predykcji defektów na poziomie metod i jaka jest ich skutecznoœæ?}
		\\Istnieje wiele modeli predykcji defektów, jednak wiêkszoœæ z nich opiera siê na danych dotycz¹cych klas, pakietów lub modu³ów. Odpowiedzi¹ na powy¿sze pytanie jest zbiór modeli predykcji defektów na niskim poziomie granulacji, na przyk³ad metod lub bloków kodu.
	\item {\bf Jakie s¹ mo¿liwoœci usprawnienia lub rozwiniêcia istniej¹cych metod?}
		\\Zosta³y zebrane wszelkie mo¿liwoœci ulepszenia lub rozszerzenia badañ wskazanych przez autorów, okreœlone np. jako ``Dalszy rozwój".
	\item {\bf Jakie s¹ sposoby ekstrakcji zmian kodu Ÿród³owego na poziomie metod?}
		\\Jakie s¹ sposoby porównywania wersji kodu Ÿród³owego, jakiego rodzaju dane (metryki) s¹ uzyskiwane.
\end{itemize}

Podczas wstêpnego rozpoznania dziedziny zauwa¿ono, ¿e liczba publikacji jest niewielka. W zwi¹zku z tym postanowiono przeprowadziæ wyszukiwanie w dwóch etapach. W pierwszym etapie przeszukano elektroniczne zbiory, natomiast w drugim etapie przejrzano bibliografie pozyskanych publikacji a tak¿e wszystkie publikacje ich autorów w celu odnalezienia dodatkowych tekstów.

\paragraph{Przeszukiwalne zbiory cyfrowe.}

Przeszukano poni¿sze zbiory z u¿yciem ustalonych wyra¿eñ, za pomoc¹ wyszukiwarek udostêpnianych w postaci aplikacji internetowej:
\begin{itemize}
	\item IEEE Xplore,
	\item Science Direct,
	\item ACM Digital Library,
	\item Springer Link,
	\item ISI Web of Science.
	%\item Engineering Village
	%\item Wiley Online Library
\end{itemize}

Wybrano te zbiory poniewa¿ pokrywaj¹ one wiêkszoœæ publikacji in¿ynierii oprogramowania oraz s¹ u¿ywane jako Ÿród³a w innych przegl¹dach z tej dziedziny \cite{hall2012systematic, riaz2009systematic}.

\paragraph{Szara literatura.}

Wstêpne przeszukiwanie wykaza³o niewielk¹ iloœæ Ÿróde³ œciœle odpowiadaj¹cych zagadnieniu predykcji defektów na niskim poziomie granulacji. Aby pokryæ znaczn¹ czêœæ szarej literatury zdecydowano, aby przeszukaæ nastêpuj¹ce Ÿród³a:
\begin{itemize}
	\item Google Scholar.
	\item Lista odnoœników w znalezionych Ÿród³ach pierwotnych.
		\\Zgodnie z metod¹ œnie¿nej kuli \cite{goodman1961snowball} przejrzano listy referencji Ÿróde³ pierwotnych w celu odnalezienia dodatkowych istotnych (relewantnych) publikacji.
	\item Inne publikacje autorów znalezionych Ÿróde³ pierwotnych.
		\\Przeszukano bazê DBLP \cite{DBLP:2014:Online} szukaj¹c wed³ug nazwisk autorów dotychczas zgromadzonych Ÿróde³ pierwotnych.
\end{itemize}


Po dokonaniu przegl¹du literatury oraz oceny znalezionych Ÿróde³, wybrano te najbardziej istotne z punktu widzenia niniejszej pracy:
\begin{itemize}
	\item \textit{Declarative visitors to ease fine-grained source code mining with full history on billions of AST nodes.} \cite{dyer2013declarative}
	\item \textit{Method-level bug prediction.} \cite{giger2012method}
	\item \textit{Comparing fine-grained source code changes and code churn for bug prediction.} \cite{giger2011comparing}
	\item \textit{Fault-prone Module Prediction Using Version Histories.} \cite{hata2012fault}
	\item \textit{Reconstructing fine-grained versioning repositories with git for method-level bug prediction.} \cite{hata2010reconstructing}
	\item \textit{Historage: fine-grained version control system for Java.} \cite{hata2011historage}
	\item \textit{Bug prediction based on fine-grained module histories.} \cite{hata2012bug}
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Struktura pracy}

\noindent \todo{TODO Omówienie zawartoœci rozdzia³ów}
